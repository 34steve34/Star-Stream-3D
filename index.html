<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Star Stream 3D - v4.9.4</title>
	<link rel="manifest" href="manifest.json">
    
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; color: #0f0; touch-action: none; }
        #ui { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); text-align: center; width: 100%; z-index: 10; display: flex; flex-direction: column; align-items: center; gap: 15px; }
		#zeroBtn { position: absolute; top: 10px; left: 10px; padding: 10px; background: #222; color: #0f0; border: 1px solid #0f0; z-index: 30; font-size: 10px; cursor: pointer; border-radius: 5px; }
        #version { position: absolute; top: 10px; right: 10px; color: rgba(255, 120, 0, 0.7); font-size: 10px; z-index: 30; }
        #thrustBtn { position: absolute; bottom: 20px; right: 20px; width: 104px; height: 104px; background: rgba(255, 120, 0, 0.3); color: white; border: 2px solid #ff7800; border-radius: 50%; cursor: pointer; font-size: 14px; z-index: 20; display: none; -webkit-user-select: none; }
        #thrustBtn.active { background: rgba(255, 120, 0, 0.7); }
        #hud { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); text-align: center; color: #0ff; font-size: 16px; display: none; width: 100%; pointer-events: none; }
        #timer { color: #ff00ff; font-weight: bold; font-size: 20px; }
        
        #splashInfo {
            background: rgba(0, 0, 0, 0.85); border: 2px solid #00E676; padding: 15px;
            border-radius: 8px; width: 280px; box-shadow: 0 0 15px rgba(0, 230, 118, 0.2);
        }
        #splashInfo h2 { margin: 0 0 10px 0; color: #fff; font-size: 18px; letter-spacing: 1px; }
        .legend-row { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; font-size: 14px; }
        .color-box { width: 16px; height: 16px; border-radius: 50%; display: inline-block; margin-right: 10px; }
        .legend-text { color: #ddd; flex-grow: 1; text-align: left; }
        .legend-pts { color: #fff; font-weight: bold; }

        #scopeCanvas { 
            position: absolute; top: 50px; right: 20px; 
            width: 220px; height: 220px; border: 3px solid rgba(255, 0, 0, 0.8); 
            border-radius: 50%; z-index: 15; display: none;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); background: #000;
        }
        #scopeCrosshair {
            position: absolute; top: 50px; right: 20px;
            width: 220px; height: 220px; z-index: 17; display: none; pointer-events: none;
        }
        
        #scopeReticle {
            position: absolute; bottom: 130px; left: 50%; transform: translate(-50%, -50%);
            width: 6px; height: 6px; background: radial-gradient(circle, #ff0000 0%, rgba(255, 0, 0, 0.8) 50%, rgba(255, 0, 0, 0) 100%);
            border-radius: 50%; z-index: 16; display: none; box-shadow: 0 0 8px #ff0000;
        }

        #pointPop {
            position: absolute;
            top: 150px; 
            right: 280px;
            color: #ffaa00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffaa00;
            opacity: 0;
            z-index: 50;
            pointer-events: none;
            transition: opacity 0.2s ease-out;
        }

        .indicator { 
            position: absolute; 
            border-radius: 50%; 
            pointer-events: none; 
            z-index: 5; 
            transform: translate(-50%, -50%); 
        }

        button#startBtn { padding: 15px 30px; font-size: 18px; background: #00E676; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; width: 280px; box-shadow: 0 0 15px rgba(0, 230, 118, 0.4); }
       
        #results {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; display: none; background: rgba(0,0,0,0.95); padding: 20px 30px; 
            border: 2px solid #00E676; z-index: 110; box-shadow: 0 0 30px rgba(0,230,118,0.3);
            width: 85%; max-width: 600px;
            border-radius: 10px;
        }
        #results h1 { color: #fff; font-size: 24px; margin: 0 0 15px 0; letter-spacing: 2px; }
        
        /* New Current Run Stats Layout */
        .current-stats-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .stat-box { display: flex; flex-direction: column; align-items: center; }
        .stat-label { font-size: 14px; letter-spacing: 2px; margin-bottom: 5px; }
        .stat-value { font-size: 48px; font-weight: bold; line-height: 1; }
        
        .score-green { color: #00E676; text-shadow: 0 0 15px rgba(0,230,118,0.5); }
        .score-orange { color: #ffaa00; text-shadow: 0 0 15px rgba(255,170,0,0.5); }
        
        .leaderboards-container {
            display: flex; justify-content: space-between; gap: 30px; margin-bottom: 15px;
        }
        .leaderboard-col { flex: 1; }
        
        .score-section-title { font-size: 16px; font-weight: bold; color: #fff; text-align: center; border-bottom: 2px solid #00E676; padding-bottom: 5px; margin-bottom: 10px; }
        .score-list { text-align: left; color: #fff; font-size: 16px; }
        .score-row { display: flex; justify-content: space-between; border-bottom: 1px dashed rgba(0, 230, 118, 0.4); padding: 6px 0; }
        .score-row:last-child { border-bottom: none; }
        
        #replayBtn { padding: 12px 20px; font-size: 18px; cursor: pointer; background: #00E676; color: #000; border: none; border-radius: 5px; font-weight: bold; width: 100%; text-transform: uppercase; box-shadow: 0 0 10px rgba(0,230,118,0.4); }

    </style>
</head>
<body>
    <div id="version">v4.9.4</div>
    <button id="zeroBtn">ZERO</button>
    <button id="thrustBtn">THRUST</button>
    
    <div id="hud">
        <div id="timer">03:00</div>
        <div>SCORE: <span id="score">0</span></div>
        <div>WAVE: <span id="wave">1</span> | TARGETS: <span id="targets">0</span></div>
    </div>
    
    <div id="ui">
        <div id="splashInfo">
            <h2>TARGET INTEL</h2>
            <div class="legend-row">
                <div class="color-box" style="background: #00ff00; box-shadow: 0 0 8px #00ff00;"></div>
                <span class="legend-text">Close Range</span>
                <span class="legend-pts">LOW PTS</span>
            </div>
            <div class="legend-row">
                <div class="color-box" style="background: #ffff00; box-shadow: 0 0 8px #ffff00;"></div>
                <span class="legend-text">Mid Range</span>
                <span class="legend-pts">MED PTS</span>
            </div>
            <div class="legend-row">
                <div class="color-box" style="background: #ffaa00; box-shadow: 0 0 8px #ffaa00;"></div>
                <span class="legend-text">Long Range</span>
                <span class="legend-pts">HIGH PTS</span>
            </div>
            <div class="legend-row">
                <div class="color-box" style="background: #ff00ff; box-shadow: 0 0 8px #ff00ff;"></div>
                <span class="legend-text">Extreme Range</span>
                <span class="legend-pts">MAX PTS</span>
            </div>
        </div>
        <button id="startBtn">START MISSION</button>
    </div>

    <div id="indicator-container"></div>
    <canvas id="scopeCanvas"></canvas>
    <canvas id="scopeCrosshair" width="220" height="220"></canvas>
    <div id="scopeReticle"></div>
    <div id="pointPop">+0</div>

    <div id="results">
        <h1>MISSION COMPLETE</h1>
        
        <div class="current-stats-container">
            <div class="stat-box">
                <div class="stat-label score-green">YOUR SCORE</div>
                <div class="stat-value score-green" id="finalScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label score-orange">BEST SHOT</div>
                <div class="stat-value score-orange" id="currentBestShotUI">0</div>
            </div>
        </div>
        
        <div class="leaderboards-container">
            <div class="leaderboard-col">
                <div class="score-section-title">TOP 4 TOTAL SCORES</div>
                <div class="score-list">
                    <div class="score-row"><span>1.</span><span id="ts1">0</span></div>
                    <div class="score-row"><span>2.</span><span id="ts2">0</span></div>
                    <div class="score-row"><span>3.</span><span id="ts3">0</span></div>
                    <div class="score-row"><span>4.</span><span id="ts4">0</span></div>
                </div>
            </div>
            <div class="leaderboard-col">
                <div class="score-section-title">TOP 4 BEST SHOTS</div>
                <div class="score-list">
                    <div class="score-row"><span>1.</span><span id="bs1">0</span></div>
                    <div class="score-row"><span>2.</span><span id="bs2">0</span></div>
                    <div class="score-row"><span>3.</span><span id="bs3">0</span></div>
                    <div class="score-row"><span>4.</span><span id="bs4">0</span></div>
                </div>
            </div>
        </div>
        <button id="replayBtn">PLAY AGAIN</button>
    </div>
	
    <script type="importmap">
        {
            "imports": {
                "three": "./libs/three.module.js",
                "three/addons/": "./libs/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const CONFIG = {
            MAX_VELOCITY: 1.5, DRIFT_INERTIA: 0.95, ACCEL_FORCE: 0.08, BULLET_SPEED: 9,
            PITCH_SENSITIVITY: 0.02, YAW_SENSITIVITY: 0.018, EXPONENT: 1.6, DEADZONE: 1.2,
            SECTOR_SIZE: 3500, LOCAL_STAR_COUNT: 800, LOCAL_STAR_RANGE: 800,
            CAMERA_RADIUS: 80, MISSION_TIME: 180, BASE_FOV: 75, MAX_FOV_BOOST: 18,
            FOV_SMOOTHING: 0.03, SCOPE_RANGE: 2000, SCOPE_FOV: 30, SCOPE_FORWARD_OFFSET: 8,
            SCOPE_HIT_DISTANCE: 150, EXPLOSION_SHARDS: 20, SHAKE_INTENSITY: 2.0
        };

        let scene, camera, renderer, ship, engineBeam, engineLight;
		const clock = new THREE.Clock();
		let gunTipVelocity = new THREE.Vector3();
		let prevGunTipPos = new THREE.Vector3();
        let scopeCamera, scopeRenderer, scopeCanvas, scopeReticle;
        let starFields = [], localStars, targets = [], bullets = [], trails = [], explosions = [];
        let phoneZero = { beta: 0, gamma: 0 }, currentRotationVel = { p: 0, y: 0 };
        let isInitialized = false, isThrusting = false, gameActive = false, pendingShot = false;
        let velocityVec = new THREE.Vector3(0, 0, 0);
        let lastShipPos = new THREE.Vector3();
        let score = 0, wave = 1, targetsInWave = 12, timeLeft = CONFIG.MISSION_TIME;
        let shakeDuration = 0;
        let activeScopeBullet = null;
        let popTimeout = null;
        let currentBestShot = 0; // Tracks the best shot for the current game
		// === GYRO INTEGRATION v4.7.7 (posture-independent tilt) ===
		let relativeTilt = { p: 0, y: 0 };
		let lastMotionTime = 0;
		let currentRotationRate = { alpha: 0, beta: 0, gamma: 0 };
        
        let audioCtx; // Web Audio API Context

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(CONFIG.BASE_FOV, window.innerWidth / window.innerHeight, 1, 30000);
            camera.position.set(0, 10, 40);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
			clock.start();
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(10, 20, 10);
            scene.add(sun);
            initScope(); 
            initStars(); 
            initLocalStars(); 
            spawnWave(); 
            startTimer(); 
            animate();
        }

        // --- DYNAMIC AUDIO GENERATOR ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playExplosionSound(points = 20) {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const intensity = Math.min(1, points / 90);   // magenta hits â‰ˆ 1.0

    // 1. Sharp initial CRACK (scary transient)
    const crack = audioCtx.createOscillator();
    const crackGain = audioCtx.createGain();
    const crackFilter = audioCtx.createBiquadFilter();
    crack.type = 'sawtooth';
    crack.frequency.setValueAtTime(420 + Math.random() * 80, t);
    crackFilter.type = 'lowpass';
    crackFilter.frequency.setValueAtTime(1800, t);
    crackFilter.frequency.exponentialRampToValueAtTime(400, t + 0.12);
    crackGain.gain.setValueAtTime(1.1 * intensity, t);
    crackGain.gain.exponentialRampToValueAtTime(0.001, t + 0.18);

    crack.connect(crackFilter).connect(crackGain).connect(audioCtx.destination);
    crack.start(t);
    crack.stop(t + 0.2);

    // 2. Main body boom (your original but meaner & intensity-scaled)
    const boom = audioCtx.createOscillator();
    const boomGain = audioCtx.createGain();
    boom.type = 'sine';
    boom.frequency.setValueAtTime(135 - 25 * intensity, t);     // deeper on big hits
    boom.frequency.exponentialRampToValueAtTime(18, t + 0.55 + 0.25 * intensity);
    boomGain.gain.setValueAtTime(2.2 * intensity, t);
    boomGain.gain.exponentialRampToValueAtTime(0.001, t + 0.9 + 0.4 * intensity);

    boom.connect(boomGain).connect(audioCtx.destination);
    boom.start(t);
    boom.stop(t + 1.4);

    // 3. Sub rumble tail (the â€œoh shitâ€ low end)
    const sub = audioCtx.createOscillator();
    const subGain = audioCtx.createGain();
    sub.type = 'sine';
    sub.frequency.setValueAtTime(48 - 12 * intensity, t);
    sub.frequency.exponentialRampToValueAtTime(12, t + 1.1 + 0.6 * intensity);
    subGain.gain.setValueAtTime(0.9 * intensity, t + 0.15);
    subGain.gain.exponentialRampToValueAtTime(0.001, t + 1.6 + 0.7 * intensity);

    sub.connect(subGain).connect(audioCtx.destination);
    sub.start(t + 0.15);
    sub.stop(t + 2.4);
}
        function initScope() {
            scopeCanvas = document.getElementById('scopeCanvas');
            scopeReticle = document.getElementById('scopeReticle');
            scopeCamera = new THREE.PerspectiveCamera(CONFIG.SCOPE_FOV, 1, 1, 3000);
            scopeRenderer = new THREE.WebGLRenderer({ canvas: scopeCanvas, antialias: true });
            scopeRenderer.setSize(220, 220);
            scopeRenderer.setClearColor(0x000000, 1.0);
            
            const crosshairCanvas = document.getElementById('scopeCrosshair');
            const ctx = crosshairCanvas.getContext('2d');
            const centerX = 110, centerY = 110, lineLength = 55, gap = 8;
            
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.95)'; 
            ctx.lineWidth = 1.2;
            ctx.beginPath(); ctx.moveTo(centerX, centerY - gap); ctx.lineTo(centerX, centerY - gap - lineLength); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(centerX, centerY + gap); ctx.lineTo(centerX, centerY + gap + lineLength); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(centerX - gap, centerY); ctx.lineTo(centerX - gap - lineLength, centerY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(centerX + gap, centerY); ctx.lineTo(centerX + gap + lineLength, centerY); ctx.stroke();
            
            ctx.fillStyle = 'rgba(255, 0, 0, 0.95)'; 
            ctx.beginPath(); ctx.arc(centerX, centerY, 1.5, 0, Math.PI * 2); ctx.fill();
        }

       function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            if (ship && isInitialized) {
                const camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

                // --- PITCH-AWARE YAW RATE CAP ---
                // currentRotationVel.y is a per-frame radian value (max ~0.03 from applyCurve).
                // At high pitch the yaw orbit shrinks by cos(pitchAngle), so the same
                // per-frame radians produces a much faster apparent spin near the poles.
                // We scale the cap by orbitRadius so apparent spin rate stays constant
                // regardless of pitch. No dt needed â€” units are already per-frame.
                const shipForwardForCap = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.quaternion);
                const pitchAngleForCap = Math.asin(Math.max(-1, Math.min(1, shipForwardForCap.y)));
                const orbitRadius = Math.max(0.08, Math.cos(pitchAngleForCap)); // never fully zero
                // MAX_YAW_PER_FRAME: at flat pitch this is the ceiling (tune to taste).
                // 0.03 = current uncapped max from YAW_SENSITIVITY, so start just below that.
                const MAX_YAW_PER_FRAME = CONFIG.YAW_SENSITIVITY; // same as applyCurve's ceiling
                const maxYawVel = MAX_YAW_PER_FRAME * orbitRadius;
                currentRotationVel.y = Math.max(-maxYawVel, Math.min(maxYawVel, currentRotationVel.y));
                // --- END YAW CAP ---

                ship.rotateOnWorldAxis(camUp, -currentRotationVel.y);
                
                // Derive shipRight AFTER yaw so pitch axis is fresh and orthogonal
                const shipRight = new THREE.Vector3(1, 0, 0).applyQuaternion(ship.quaternion);
                const shipForward = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.quaternion);
                const currentPitchAngle = Math.asin(Math.max(-1, Math.min(1, shipForward.y)));
                const MAX_PITCH = Math.PI * 0.47;
                const proposedPitch = currentPitchAngle - currentRotationVel.p;
                
                if (proposedPitch > -MAX_PITCH && proposedPitch < MAX_PITCH) {
                    ship.rotateOnWorldAxis(shipRight, -currentRotationVel.p);
                }
                
                const currentGunTipPos = new THREE.Vector3(0, 0, 15).applyQuaternion(ship.quaternion).add(ship.position);
                if (prevGunTipPos.lengthSq() === 0) prevGunTipPos.copy(currentGunTipPos);
                if (dt > 0) gunTipVelocity.subVectors(currentGunTipPos, prevGunTipPos);
                prevGunTipPos.copy(currentGunTipPos);
                
                if (pendingShot) { 
                    fireLaser(); 
                    pendingShot = false; 
                }
                
                if (isThrusting) {
                    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.quaternion).normalize();
                    velocityVec.add(dir.multiplyScalar(CONFIG.ACCEL_FORCE));
                    if (velocityVec.length() > CONFIG.MAX_VELOCITY) velocityVec.setLength(CONFIG.MAX_VELOCITY);
                    engineBeam.scale.set(1, 1.2 + Math.random() * 0.8, 1); 
                    engineLight.intensity = 3000;
                } else {
                    velocityVec.multiplyScalar(CONFIG.DRIFT_INERTIA);
                    engineBeam.scale.set(0, 0, 0); 
                    engineLight.intensity = 0;
                }
                ship.position.add(velocityVec);
                
                const targetFov = CONFIG.BASE_FOV + (velocityVec.length() / CONFIG.MAX_VELOCITY * CONFIG.MAX_FOV_BOOST);
                camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, CONFIG.FOV_SMOOTHING);
                camera.updateProjectionMatrix();
                
                handleStarWrap(); handleLocalStars(); updateIndicators(); updateScope(); updateExplosions();
                
                const dist = ship.position.distanceTo(camera.position);
                if (dist > CONFIG.CAMERA_RADIUS) {
                    camera.position.add(new THREE.Vector3().subVectors(ship.position, camera.position).normalize().multiplyScalar((dist - CONFIG.CAMERA_RADIUS) * 0.02));
                }
                
                const targetQuat = new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(camera.position, ship.position, new THREE.Vector3(0, 1, 0).applyQuaternion(ship.quaternion)));
                camera.quaternion.slerp(targetQuat, 0.08);
                
                if (shakeDuration > 0) {
                    const offset = (Math.random() - 0.5) * CONFIG.SHAKE_INTENSITY * (shakeDuration / 0.25);
                    camera.position.x += offset; camera.position.y += offset; 
                    shakeDuration -= 0.016;
                }
            }
            
            targets.forEach(t => {
                t.userData.angle += t.userData.speed;
                const offset = new THREE.Vector3(Math.cos(t.userData.angle) * t.userData.radius, 0, Math.sin(t.userData.angle) * t.userData.radius);
                offset.applyQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), t.userData.axis));
                t.position.copy(t.userData.center).add(offset);
                
                if (ship) {
                    const targetDist = ship.position.distanceTo(t.position);
                    if (targetDist < 400) { t.material.color.setHex(0x00ff00); t.material.emissive.setHex(0x004400); } 
                    else if (targetDist < 800) { t.material.color.setHex(0xffff00); t.material.emissive.setHex(0x444400); } 
                    else if (targetDist < 1200) { t.material.color.setHex(0xffaa00); t.material.emissive.setHex(0x442200); } 
                    else { t.material.color.setHex(0xff00ff); t.material.emissive.setHex(0x440044); }
                }
            });
                if (debugActive) { 
					drawGraph(); 
					updateNumbers(relativeTilt.p, relativeTilt.y, currentRotationVel.p, currentRotationVel.y); 
				}
			
            handleBullets(); renderer.render(scene, camera);
        }

        function fireLaser() {
            if (!ship || !gameActive) return;
            const spawnPos = new THREE.Vector3(0, 0, 15).applyQuaternion(ship.quaternion).add(ship.position);
            const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.quaternion).normalize();
            const finalVelocity = new THREE.Vector3().add(forwardDir.multiplyScalar(CONFIG.BULLET_SPEED)).add(gunTipVelocity); 
            
            const p = new THREE.Group();
            p.add(new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff00ff })), new THREE.PointLight(0xff00ff, 4500, 200));
            p.position.copy(spawnPos); 
            p.userData = { velocity: finalVelocity, origin: spawnPos.clone(), spawn: Date.now() };
            scene.add(p); bullets.push(p); activeScopeBullet = p;
        }

        function spawnWave() {
            const center = ship ? ship.position : new THREE.Vector3(0,0,-100);
            for (let i = 0; i < targetsInWave; i++) {
                const t = new THREE.Mesh(new THREE.IcosahedronGeometry(15, 0), new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x004400 }));
                const orbitRadius = 300 + Math.random() * 1100; 
                const orbitAngle = Math.random() * Math.PI * 2;
                t.position.set(center.x + Math.cos(orbitAngle) * orbitRadius, center.y + (Math.random()-0.5)*600, center.z + Math.sin(orbitAngle) * orbitRadius);
                t.userData = { 
                    center: t.position.clone(), radius: orbitRadius, 
                    speed: ((Math.random()*0.001)+0.00065) * (Math.random() < 0.5 ? 1 : -1), 
                    angle: orbitAngle, axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize() 
                };
                scene.add(t); targets.push(t);
            }
            updateHUD();
        }
        
        function showPointPop(pts) {
            const popEl = document.getElementById('pointPop'); popEl.innerText = `+${pts}`; popEl.style.opacity = 1;
            clearTimeout(popTimeout); popTimeout = setTimeout(() => { popEl.style.opacity = 0; }, 600);
        }

        function updateBestShots(points) {
            let bestShots = JSON.parse(localStorage.getItem('starStreamBestShots')) || [0, 0, 0, 0];
            if (points > bestShots[3]) { 
                bestShots.push(points); bestShots.sort((a, b) => b - a); bestShots = bestShots.slice(0, 4); 
                localStorage.setItem('starStreamBestShots', JSON.stringify(bestShots)); 
            }
        }

        function handleBullets() {
            bullets.forEach((b, bi) => {
                b.position.add(b.userData.velocity);
                targets.forEach((t, ti) => {
                    if (b.position.distanceTo(t.position) < 28) {
                        const earnedPoints = 10 + Math.floor(b.position.distanceTo(b.userData.origin) / 10);
						score += earnedPoints; 
                        
                        // Track Best Shot for THIS game
                        if (earnedPoints > currentBestShot) {
                            currentBestShot = earnedPoints;
                        }
                        
                        showPointPop(earnedPoints); 
                        updateBestShots(earnedPoints); 
                        playExplosionSound(earnedPoints); // TRIGGERS THE AUDIO BOOM
                        createExplosion(t.position);
                        
                        scene.remove(t); targets.splice(ti, 1); scene.remove(b); bullets.splice(bi, 1);
                        if (targets.length === 0) { wave++; targetsInWave += 4; spawnWave(); }
                        updateHUD();
                    }
                });
                if (Date.now() - b.userData.spawn > 5000) { scene.remove(b); bullets.splice(bi, 1); }
            });
        }

        function createExplosion(pos) {
            shakeDuration = 0.25;
            for (let i = 0; i < CONFIG.EXPLOSION_SHARDS; i++) {
                const randomColor = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
                const shard = new THREE.Mesh(new THREE.TetrahedronGeometry(Math.random()*8+4), new THREE.MeshBasicMaterial({ color: randomColor, transparent: true, opacity: 1 }));
                shard.position.copy(pos); 
                shard.userData = { velocity: new THREE.Vector3((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*15), life: 1.0 };
                scene.add(shard); explosions.push(shard);
            }
        }

        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const s = explosions[i]; s.position.add(s.userData.velocity); s.userData.life -= 0.02; s.material.opacity = s.userData.life;
                if (s.userData.life <= 0) { scene.remove(s); explosions.splice(i, 1); }
            }
        }

        function handleStarWrap() {
            starFields.forEach(field => {
                const diff = new THREE.Vector3().subVectors(field.position, ship.position); const s = CONFIG.SECTOR_SIZE;
                if (Math.abs(diff.x) > s * 1.5) field.position.x -= Math.sign(diff.x) * s * 3;
                if (Math.abs(diff.y) > s * 1.5) field.position.y -= Math.sign(diff.y) * s * 3;
                if (Math.abs(diff.z) > s * 1.5) field.position.z -= Math.sign(diff.z) * s * 3;
            });
        }

        function handleLocalStars() {
            if(!localStars || !ship) return;
            // Compute how much the ship moved this frame and shift stars the opposite way
            const delta = new THREE.Vector3().subVectors(ship.position, lastShipPos);
            lastShipPos.copy(ship.position);
            const positions = localStars.geometry.attributes.position.array; const range = CONFIG.LOCAL_STAR_RANGE;
            for(let i=0; i<positions.length; i+=3) {
                positions[i]   -= delta.x;
                positions[i+1] -= delta.y;
                positions[i+2] -= delta.z;
                if(positions[i+2] > range/2) positions[i+2] -= range; if(positions[i+2] < -range/2) positions[i+2] += range;
                if(positions[i] > range/2) positions[i] -= range; if(positions[i] < -range/2) positions[i] += range;
                if(positions[i+1] > range/2) positions[i+1] -= range; if(positions[i+1] < -range/2) positions[i+1] += range;
            }
            localStars.geometry.attributes.position.needsUpdate = true;
        }

        function initStars() {
            const geo = new THREE.BufferGeometry(); const pos = new Float32Array(250 * 3);
            for(let i=0; i<250*3; i++) pos[i] = (Math.random()-0.5) * CONFIG.SECTOR_SIZE;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 12, transparent: true, opacity: 0.8 });
            for(let x=-1; x<=1; x++) for(let y=-1; y<=1; y++) for(let z=-1; z<=1; z++) {
                const p = new THREE.Points(geo, mat); p.position.set(x*CONFIG.SECTOR_SIZE, y*CONFIG.SECTOR_SIZE, z*CONFIG.SECTOR_SIZE);
                scene.add(p); starFields.push(p);
            }
        }

        function initLocalStars() {
            const geo = new THREE.BufferGeometry(); const pos = new Float32Array(CONFIG.LOCAL_STAR_COUNT * 3);
            for(let i=0; i<CONFIG.LOCAL_STAR_COUNT * 3; i++) pos[i] = (Math.random()-0.5) * CONFIG.LOCAL_STAR_RANGE;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            localStars = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, transparent: true, opacity: 0.7 }));
            scene.add(localStars);
        }

        function updateIndicators() {
            const container = document.getElementById('indicator-container');
            container.innerHTML = ''; if(!ship || !gameActive) return;
            
            const frustum = new THREE.Frustum().setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
            targets.forEach(t => {
                const vector = t.position.clone().project(camera);
                if (frustum.containsPoint(t.position)) return;
                
                const div = document.createElement('div'); div.className = 'indicator';
                
                const dist = ship.position.distanceTo(t.position);
                const size = Math.max(10, Math.min(40, 40 - (dist / 2000) * 30));
                div.style.width = `${size}px`; div.style.height = `${size}px`;
                const hexColor = t.material.color.getHexString();
                div.style.background = `radial-gradient(circle, #${hexColor} 0%, rgba(0,0,0,0) 80%)`;
                div.style.border = `1px solid #${hexColor}`;
                
                const margin = 10; let x, y;
                
                if (vector.z > 1) { 
                    const dirX = vector.x; const dirY = -vector.y; const len = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (len < 0.001) { x = window.innerWidth / 2; y = window.innerHeight - margin; }
                    else { const normX = dirX / len, normY = dirY / len; const halfW = window.innerWidth / 2, halfH = window.innerHeight / 2; const tLim = Math.min((halfW-margin)/Math.abs(normX), (halfH-margin)/Math.abs(normY)); x = halfW + normX * tLim; y = halfH + normY * tLim; }
                } else {
                    x = (vector.x * (window.innerWidth/2)) + (window.innerWidth/2); y = -(vector.y * (window.innerHeight/2)) + (window.innerHeight/2);
                    x = Math.max(margin, Math.min(window.innerWidth - margin, x)); y = Math.max(margin, Math.min(window.innerHeight - margin, y));
                }
                div.style.left = `${x}px`; div.style.top = `${y}px`; container.appendChild(div);
            });
        }

        function updateScope() {
            if (!ship || !gameActive) return;
            const shipForward = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.quaternion).normalize();
            let activeTarget = null; let shortestDist = Infinity;
            
            for (let t of targets) {
                const targetVec = t.position.clone().sub(ship.position); const projection = targetVec.dot(shipForward);
                if (projection > 0 && projection < CONFIG.SCOPE_RANGE) {
                    const lateralDist = ship.position.clone().add(shipForward.clone().multiplyScalar(projection)).distanceTo(t.position);
                    if (lateralDist < CONFIG.SCOPE_HIT_DISTANCE && projection < shortestDist) { shortestDist = projection; activeTarget = t; }
                }
            }
            
            if (activeTarget || (activeScopeBullet && bullets.includes(activeScopeBullet))) {
                scopeCamera.position.copy(ship.position).add(shipForward.clone().multiplyScalar(CONFIG.SCOPE_FORWARD_OFFSET));
                scopeCamera.quaternion.copy(ship.quaternion); scopeCamera.rotateY(Math.PI);
                scopeRenderer.render(scene, scopeCamera); scopeCanvas.style.display = 'block'; document.getElementById('scopeCrosshair').style.display = 'block';
            } else { scopeCanvas.style.display = 'none'; document.getElementById('scopeCrosshair').style.display = 'none'; }
        } 

      // ====================== HOOKS (replace your old ones) ======================
	function onDeviceMove(e) {
    if (!gameActive) return;
    
    let pDiff = relativeTilt.p;
    let yDiff = relativeTilt.y;
    
    const applyCurve = (val, sens) => (Math.abs(val) < CONFIG.DEADZONE) ? 0 : Math.sign(val) * Math.pow(Math.min(Math.abs(val)/35, 1), CONFIG.EXPONENT) * sens;
    
    currentRotationVel.p = -applyCurve(pDiff, CONFIG.PITCH_SENSITIVITY);
    currentRotationVel.y = applyCurve(yDiff, CONFIG.YAW_SENSITIVITY);
    
    // Very gentle pitch anti-drift only when nearly neutral â€” yaw holds freely
    if (Math.abs(pDiff) < 5) {
        relativeTilt.p *= 0.97;
    }
    // No yaw anti-drift: accumulates for unlimited rotation
    
    if (debugActive) {
        lastBeta = e.beta || 0; lastGamma = e.gamma || 0;
        history.beta.push(lastBeta); history.gamma.push(lastGamma);
        history.pDiff.push(pDiff); history.yDiff.push(yDiff);
        history.pitchVel.push(currentRotationVel.p); history.yawVel.push(currentRotationVel.y);
        history.gravX.push(accGravity.x * 25);
        history.gravY.push(accGravity.y * 25);
        history.gravZ.push(accGravity.z * 25);
        if (history.beta.length > MAX_HISTORY) Object.keys(history).forEach(k => history[k].shift());
    }
}

        function displayEndScreen() {
            let topScores = JSON.parse(localStorage.getItem('starStreamHighScores')) || [0, 0, 0, 0];
            topScores.push(score); topScores.sort((a, b) => b - a); topScores = topScores.slice(0, 4); localStorage.setItem('starStreamHighScores', JSON.stringify(topScores));
            
            let bestShots = JSON.parse(localStorage.getItem('starStreamBestShots')) || [0, 0, 0, 0];
            
            document.getElementById('finalScore').innerText = score;
            document.getElementById('currentBestShotUI').innerText = currentBestShot;
            
            document.getElementById('ts1').innerText = topScores[0]; document.getElementById('ts2').innerText = topScores[1]; document.getElementById('ts3').innerText = topScores[2]; document.getElementById('ts4').innerText = topScores[3];
            document.getElementById('bs1').innerText = bestShots[0]; document.getElementById('bs2').innerText = bestShots[1]; document.getElementById('bs3').innerText = bestShots[2]; document.getElementById('bs4').innerText = bestShots[3];
            
            document.getElementById('results').style.display = 'block'; document.getElementById('hud').style.display = 'none'; document.getElementById('thrustBtn').style.display = 'none';
        }

        function startTimer() {
            const timerInterval = setInterval(() => {
                if (timeLeft > 0 && gameActive) { 
                    timeLeft--; document.getElementById('timer').textContent = `${Math.floor(timeLeft/60).toString().padStart(2,'0')}:${(timeLeft%60).toString().padStart(2,'0')}`; 
                } else if (timeLeft <= 0 && gameActive) { 
                    gameActive = false; clearInterval(timerInterval); displayEndScreen(); 
                }
            }, 1000);
        }

        function updateHUD() { document.getElementById('score').textContent = score; document.getElementById('wave').textContent = wave; document.getElementById('targets').textContent = targets.length; }

        document.getElementById('startBtn').addEventListener('click', async function() {
            document.getElementById('ui').style.display = 'none'; document.getElementById('hud').style.display = 'block'; document.getElementById('thrustBtn').style.display = 'block';
            
            initAudio(); // Initialize audio context on user gesture
            
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                await DeviceOrientationEvent.requestPermission();
            }
            window.addEventListener('deviceorientation', onDeviceMove); 
            gameActive = true; 
			isInitialized = true;
            init();
            
            new GLTFLoader().load('./assets/ship.glb', (gltf) => {
                ship = gltf.scene; ship.scale.setScalar(3.0); ship.position.set(0, 0, -100); ship.rotation.set(0, Math.PI, 0);
                lastShipPos.copy(ship.position);
                engineBeam = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.05, 12, 8), new THREE.MeshBasicMaterial({ color: 0xff7700, transparent: true, opacity: 0.8 }));
                engineBeam.position.set(0, 0, -6.5); engineBeam.rotation.x = Math.PI / 2; engineBeam.scale.set(0,0,0);
                engineLight = new THREE.PointLight(0xff7700, 0, 50); engineLight.position.set(0, 0, -2);
                ship.add(engineBeam, engineLight); scene.add(ship);
            });
        });
        
        document.getElementById('replayBtn').addEventListener('click', () => location.reload());
        
        const thrustBtn = document.getElementById('thrustBtn');
        thrustBtn.addEventListener('touchstart', (e) => { e.preventDefault(); isThrusting = true; thrustBtn.classList.add('active'); }, { passive: false });
        thrustBtn.addEventListener('touchend', (e) => { e.preventDefault(); isThrusting = false; thrustBtn.classList.remove('active'); }, { passive: false });
        
        window.addEventListener('touchstart', (e) => { 
            if (gameActive && !['thrustBtn', 'zeroBtn', 'startBtn', 'replayBtn'].includes(e.target.id)) pendingShot = true; 
        });
        
		document.getElementById('zeroBtn').addEventListener('touchstart', (e) => { 
			e.preventDefault(); 
			relativeTilt = { p: 0, y: 0 };   // true center reset in ANY grip
			isInitialized = false;
			zeroTimer = setTimeout(toggleDebug, 650);
		}, {passive: false});
    
	// ==================== FULL-SCREEN SENSOR DEBUG OVERLAY (PHONE-FIXED) ====================
// ==================== SENSOR DEBUG v2 - FIXED (rolling + full gravity) ====================
let debugActive = false;
const debugOverlay = document.getElementById('debugOverlay');
const debugGraph = document.getElementById('debugGraph');
const debugCtx = debugGraph.getContext('2d');
const debugNumbers = document.getElementById('debugNumbers');
const debugClose = document.getElementById('debugClose');

let history = { beta: [], gamma: [], pDiff: [], yDiff: [], pitchVel: [], yawVel: [], gravX: [], gravY: [], gravZ: [] };
let lastBeta = 0, lastGamma = 0;
let accGravity = {x:0, y:0, z:0};
let screenAngle = 0;

const MAX_HISTORY = 950;   // fixed rolling buffer â†’ no more squeezing, data scrolls off left

function toggleDebug() {
    debugActive = !debugActive;
    debugOverlay.style.display = debugActive ? 'block' : 'none';
    if (debugActive) {
        resizeCanvas();
        history = { beta: [], gamma: [], pDiff: [], yDiff: [], pitchVel: [], yawVel: [], gravX: [], gravY: [], gravZ: [] };
    }
}

function resizeCanvas() {
    const w = Math.floor(window.innerWidth * 0.96);
    const h = Math.floor(window.innerHeight * 0.55);
    debugGraph.width = w;
    debugGraph.height = h;
}

const zeroBtn = document.getElementById('zeroBtn');
let zeroTimer = null;

zeroBtn.addEventListener('touchstart', (e) => { 
    e.preventDefault(); 
    relativeTilt = { p: 0, y: 0 };   // instant gyro reset
    isInitialized = false;
    
    zeroTimer = setTimeout(toggleDebug, 650); 
}, {passive: false});

zeroBtn.addEventListener('touchend', () => clearTimeout(zeroTimer));

debugClose.addEventListener('click', toggleDebug);
debugOverlay.addEventListener('touchstart', (e) => { if (e.target.id === 'debugOverlay') toggleDebug(); });

// === GYRO SENSITIVITY TUNER (v4.8.1) ===
// === GYRO TUNER v4.7.7 â€” fixed yaw symmetry + fine control restored ===
const GYRO_PITCH_GAIN = 0.05;
const GYRO_YAW_GAIN   = 0.03;

const RATE_DEADZONE = 2.5;   // lowered so small fine-tuning tilts still work

window.addEventListener('devicemotion', e => {
    if (e.accelerationIncludingGravity) accGravity = e.accelerationIncludingGravity;
    
    if (e.rotationRate && gameActive) {
        currentRotationRate = e.rotationRate;
        
        const now = performance.now();
        if (lastMotionTime > 0) {
            const dt = (now - lastMotionTime) / 1000;
            
            let pitchRate = (e.rotationRate.beta || 0) * (180 / Math.PI);
            let yawRate   = -(e.rotationRate.gamma || 0) * (180 / Math.PI);   // â† YAW REVERSED (as you asked)
            
            // Deadzone for noise â€” pitch holds position, yaw accumulates freely
            if (Math.abs(pitchRate) > RATE_DEADZONE) {
                relativeTilt.p += pitchRate * dt * GYRO_PITCH_GAIN;
            }
            // No auto-level for pitch: holds wherever you point it

            if (Math.abs(yawRate) > RATE_DEADZONE) {
                relativeTilt.y += yawRate * dt * GYRO_YAW_GAIN;
            }
            // No yaw decay: accumulates freely for full 360Â° continuous rotation

            // Pitch clamped to ~85Â° up/down â€” ship can't flip over
            relativeTilt.p = Math.max(-95, Math.min(95, relativeTilt.p));
            // Yaw: wrap so the number stays sane but never stops spinning
            if (relativeTilt.y > 180) relativeTilt.y -= 360;
            if (relativeTilt.y < -180) relativeTilt.y += 360;
        }
        lastMotionTime = now;
    }
});

setInterval(() => { if (screen.orientation) screenAngle = screen.orientation.angle; }, 500);

// ==================== ROLLING GRAPH (no squeezing) ====================
function drawGraph() {
    if (!debugActive) return;
    const w = debugGraph.width, h = debugGraph.height;
    debugCtx.fillStyle = '#000'; debugCtx.fillRect(0,0,w,h);

    // grid
    debugCtx.strokeStyle = 'rgba(0,255,100,0.15)';
    for (let i=1; i<10; i++) {
        const y = h*i/10; debugCtx.beginPath(); debugCtx.moveTo(0,y); debugCtx.lineTo(w,y); debugCtx.stroke();
    }

    const center = h*0.5;
    const keys = ['beta','gamma','pDiff','yDiff','pitchVel','yawVel','gravX','gravY','gravZ'];
    const colors = ['#4488ff','#ffaa00','#00ff88','#ffff44','#ff44ff','#00ffff','#ff6666','#ff2222','#aa0000'];
    const scales = [2.8, 2.8, 2.8, 2.8, 68, 68, 25, 25, 25]; // last three = gravity scaling

    debugCtx.lineWidth = 3.2;
    keys.forEach((k,i) => {
        if (history[k].length < 2) return;
        debugCtx.strokeStyle = colors[i];
        debugCtx.shadowBlur = 14; debugCtx.shadowColor = colors[i];
        debugCtx.beginPath();
        history[k].forEach((v, idx) => {
            const x = idx * (w / (history[k].length - 1));
            let scaled = center - v * scales[i];
            scaled = Math.max(25, Math.min(h-25, scaled));
            idx===0 ? debugCtx.moveTo(x,scaled) : debugCtx.lineTo(x,scaled);
        });
        debugCtx.stroke();
        debugCtx.shadowBlur = 0;
    });

    // zero line
    debugCtx.strokeStyle = 'rgba(255,255,255,0.45)'; debugCtx.lineWidth = 1.8;
    debugCtx.beginPath(); debugCtx.moveTo(0,center); debugCtx.lineTo(w,center); debugCtx.stroke();

    // legend
    debugCtx.font = '14px monospace';
    debugCtx.fillStyle = '#fff';
    const legend = [
        'BLUE raw Î²', 'ORANGE raw Î³', 'GREEN pDiff', 'YELLOW yDiff',
        'MAGENTA pitchVel', 'CYAN yawVel',
        'LT-RED gravX', 'RED gravY', 'DK-RED gravZ'
    ];
    legend.forEach((txt,i) => debugCtx.fillText(txt, 28, 38 + i*23));
}

// ==================== NUMBERS ====================
function updateNumbers(pD=0, yD=0, pVel=0, yVel=0) {
    if (!debugActive) return;
    const gMag = Math.hypot(accGravity.x, accGravity.y, accGravity.z).toFixed(1);
    debugNumbers.innerHTML = `
        <strong>RAW</strong><br>
        Î²: <span style="color:#4488ff">${lastBeta.toFixed(1)}Â°</span> (zero ${phoneZero.beta.toFixed(1)}Â°)<br>
        Î³: <span style="color:#ffaa00">${lastGamma.toFixed(1)}Â°</span> (zero ${phoneZero.gamma.toFixed(1)}Â°)<br><br>
        
        <strong>CALCULATED</strong><br>
        pDiff: <span style="color:#00ff88">${pD.toFixed(2)}Â°</span>â€ƒyDiff: <span style="color:#ffff44">${yD.toFixed(2)}Â°</span><br>
        pitchVel: <span style="color:#ff44ff">${pVel.toFixed(3)}</span>â€ƒyawVel: <span style="color:#00ffff">${yVel.toFixed(3)}</span><br><br>
        
        <strong>GRAVITY (m/sÂ²) â€” now all 3 axes</strong><br>
        X: <span style="color:#ff6666">${accGravity.x.toFixed(2)}</span>â€ƒ
        Y: <span style="color:#ff2222">${accGravity.y.toFixed(2)}</span>â€ƒ
        Z: <span style="color:#aa0000">${accGravity.z.toFixed(2)}</span><br>
        magnitude: ${gMag}â€ƒscreen: ${screenAngle}Â°
    `;
}

// ====================== HOOKS (already in place) ======================
// onDeviceMove hook and animate hook stay exactly as you added them earlier
// ====================== END OF DEBUG CODE ======================
	
	</script>
	      <!-- SENSOR DEBUG v2 - numbers on top, rolling graph, full gravity -->
    <div id="debugOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.97);z-index:2000;color:#0ff;font-family:monospace;overflow:hidden;">
        <div style="position:absolute;top:12px;left:20px;font-size:22px;color:#0f0;">ðŸ“ˆ SENSOR DEBUG v2 - FULL SCREEN</div>
        <div id="debugClose" style="position:absolute;top:12px;right:25px;font-size:36px;color:#ffaa00;cursor:pointer;">âœ•</div>
        
        <!-- NUMBERS PANEL â€” moved to TOP so you can always see it -->
        <div id="debugNumbers" style="position:absolute;top:58px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.92);padding:18px 26px;border:3px solid #0ff;border-radius:12px;font-size:16px;line-height:1.75;width:92%;max-width:780px;text-align:left;box-shadow:0 0 25px rgba(0,255,255,0.6);">
        </div>
        
        <canvas id="debugGraph" width="1280" height="520" style="position:absolute;top:215px;left:50%;transform:translateX(-50%);border:3px solid #0a0;background:#000;"></canvas>
    </div>
</body>
</html>